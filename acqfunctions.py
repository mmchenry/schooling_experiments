""" Functions used for running the acquisition of kinematics """

import videotools as vt
import cv2 as cv  # openCV for interacting with video
import os
import pandas as pd
import numpy as np

def report_version():

    print("v.6")

def get_cat_info(cat_path, include_mode='both'):
    """ Extracts key parameters from experiment catalog for making videos from image sequence.
    Videos included are the ones where analyze==1 and make_video==1.

    Column names must include 'date', 'trial_num', 'analyze', and 'make_video'
    
    cat_path:  Full path to video catalog (CSV file)
    include_mode: Criteria for what to include. Can be 'analyze', 'make_video', or 'both'

    """

    # Open CSV file
    file = open(cat_path)

    # Import CSV data
    d = pd.read_csv(file)

    # Determine which rows to include
    if include_mode=='both':
        d = d.loc[(d.analyze == 1) & (d.make_video == 1)]

    elif include_mode=='analyze':
        d = d.loc[(d.analyze == 1)]
        
    elif include_mode=='make_video':
        d = d.loc[(d.make_video == 1)]

    # Reset indices for the new rows
    d = d.reset_index(drop=True)

    return d


def make_videos(df, im_path, vid_path, vmode=False, vertpix=None, suffix_in='JPG', suffix_out='mp4', ndigits=5, prefix='DSC', imquality=0.35):
    """ Uses videotools to create videos from the image sequences from the experiments 
    
    df: dataframe generated by get_cat_info with the info needed for each video where analyze==1 and make_video==1.
    im_path: Root directory that holds the directories named for the date of the experiment.
    vid_path: Path to directory where videos will be saved.
    vmode: Verbose mode shows more output (from ffmpeg).
    vertpix: Number of pixels in verical dimension, if downsampling. Set to None, if full resolution.
    suffix_in: Suffix for source images or movies.
    suffix_out: Suffix for output movies
    ndigits: Number of digits in input image filenames
    prefix: Prefix at the start of each image filename
    imquality: Image quality (low to high: 0 to 1) for output video
    """

    # Loop thru each video listed in df
    for c_row in df.index:

        # String for experiment number
        exp_num = '0' + str(df.exp_num[c_row])

        # Paths for current output and input videos
        vid_outpath = vid_path + os.sep + df.date[c_row] + '_' + exp_num[-2:] + '.' + suffix_out
        image_path = im_path + os.sep + df.date[c_row]

        # Read number of frames from spreadsheet
        fr_start = int(df.start_imagename[c_row][len(prefix):])
        fr_end = int(df.end_imagename[c_row][len(prefix):])


        # Match output with input frame rate
        fps = df.fps[c_row]

        # Define ROI, if needed
        roi_x = df.roi_x[c_row]
        roi_y = df.roi_y[c_row]
        roi_w = df.roi_w[c_row]
        roi_h = df.roi_h[c_row]

        if not (roi_x == 'nan'):
            r = [int(float(roi_x)), int(float(roi_y)), int(float(roi_w)), int(float(roi_h))]
        else:
            r = None

        # Create movie
        vt.vid_from_seq(image_path, vid_outpath, frStart=fr_start, frEnd=fr_end, fps=fps, imQuality=imquality,
                        prefix=prefix, nDigits=ndigits, inSuffix=suffix_in, vertPix=vertpix,
                        roi=r, vMode=vmode)

        # Report counter
        print('Finished with ' + str(c_row + 1) + ' of ' + str(len(df)) + ' videos.')


def convert_videos(df, in_path, out_path, out_name=None, in_name=None,  
    vmode=True, vertpix=None, imquality=1, suffix_in='MOV', suffix_out='mp4', 
    para_mode=False, echo=True, border_pix=None):
    """ Uses videotools to convert videos from experiments

    df: dataframe generated by get_cat_info with the info needed for each video where analyze==1 and make_video==1.
    in_path: Path to input video file (without suffix).
    out_path: Path to output file (without suffix).
    in_name: File name of input file (defaults to using filename in df), 'date_trial' specifies name as date and trial number, from those columns in df (e.g., '2022-10-01_002').
    out_name: File name of output file (defaults to same as input), 'date_trial' specifies name as date and trial number, from those columns in df.
    vmode: Verbose mode shows more output (from ffmpeg)
    imquality: Image quality (low to high: 0 to 1) for output video
    suffix_in: Suffix for source images or movies
    suffix_out: Suffix for output movies
    vertpix: Size of video frames in vertical pixels 
    para_mode: Whether to run parallel processing (requires additional code)
    echo: Whether to print the steps as they are executed
    pix_extra: Number of pixels to include around the roi
    """

    if para_mode:
        # Set up empty dataframe for parallel processing of ffmpeg commands
        cmds = pd.DataFrame(columns=['command'])

    # Loop thru each video listed in df
    for c_row in df.index:

        if border_pix is not None:
            # Define ROI without extra
            roi_x = df.roi_x[c_row] - int(np.ceil(border_pix))
            roi_y = df.roi_y[c_row] - int(np.ceil(border_pix))
            roi_w = df.roi_w[c_row] + int(np.ceil(2*border_pix))
            roi_h = df.roi_h[c_row] + int(np.ceil(2*border_pix))
        else:
            # Define ROI without extra
            roi_x = df.roi_x[c_row]
            roi_y = df.roi_y[c_row]
            roi_w = df.roi_w[c_row]
            roi_h = df.roi_h[c_row]

        if not (roi_x == 'nan'):
            r = [int(float(roi_x)), int(float(roi_y)), int(float(roi_w)), int(float(roi_h))]
        else:
            r = None

        # Overwrite vertpix
        vertpix=None

        # filename via date_trial system
        if (in_name=='date_trial') or (out_name == 'date_trial'):
            trialnum = format(int(df.trial_num[c_row]),'03')
            datetrial_name = df.date[c_row] + '_' + trialnum

        elif (in_name=='date_sch_trial') or (out_name == 'date_sch_trial'):
            trialnum = format(int(df.trial_num[c_row]),'03')
            schnum = format(int(df.sch_num[c_row]),'03')
            datetrial_name = df.date[c_row] + '_sch' + schnum + '_tr' + trialnum

        # Input path
        if (in_name=='date_trial') or (in_name=='date_sch_trial'):
            tot_in_path = in_path + os.sep + datetrial_name + '.' + suffix_in
        else:
            # Total input path (video dir path + filename)
            tot_in_path = in_path + os.sep + df.date[c_row] + os.sep + df.video_filename[c_row] + '.' + suffix_in

        # Total output path (video dir path + filename)
        if (out_name == 'date_trial') or (out_name == 'date_sch_trial'):    
            tot_out_path = out_path + os.sep + datetrial_name + '.' + suffix_out
        else:
            tot_out_path = out_path + os.sep + df.video_filename[c_row] + '.' + suffix_out     

        # Check for source video
        if not os.path.isfile(tot_in_path):
            raise OSError('Video file does not exist: ' + tot_in_path)

        # Check for output directory
        if not os.path.isdir(out_path):
            raise OSError('Output directory does not exist: ' + out_path)

        # Update status
        if echo:
            print('Converting video ' + str(c_row+1) + ' of ' + str(len(df)))

        # Create movie
        cmd = vt.vid_convert(tot_in_path, tot_out_path, imQuality=imquality, vertPix=vertpix,
                       roi=r, vMode=vmode, para_mode=para_mode, echo=echo)

        if para_mode:
            cmds_c = pd.DataFrame([[cmd]],
                                columns=['command'])

            # Add to dataframe
            cmds = pd.concat([cmds, cmds_c], sort=False, ignore_index=True)

        else:
            cmds = cmd

        # Report counter
        if echo:
            print('Finished with ' + str(c_row + 1) + ' of ' + str(len(df)) + ' videos.')

    return cmds

def convert_masked_videos(df, in_path, out_path, maskpath, in_name=None,
    out_name=None, vmode=True, imquality=1, suffix_in='MOV', 
    suffix_out='mp4', para_mode=False, echo=True):
    """ Uses videotools to convert videos from experiments

    df: dataframe generated by get_cat_info with the info needed for each video where analyze==1 and make_video==1. The code assumes that videos are in a directory named for the date (e.g. 2022-10-01) for the recording, given in the 'date' column of df.
    in_path: Path to input video file (without suffix).
    out_path: Path to output file (without suffix).
    in_name: File name of input file (defaults to using filename in df), 'date_trial' specifies name as date and trial number, from those columns in df (e.g., '2022-10-01_002').
    out_name: File name of output file (defaults to same as input), 'date_trial' specifies name as date and trial number, from those columns in df.
    vmode: Verbose mode shows more output (from ffmpeg)
    imquality: Image quality (low to high: 0 to 1) for output video
    suffix_in: Suffix for source images or movies
    suffix_out: Suffix for output movies
    maskpath: Directory path for the mask image files
    para_mode: Whether to run parallel processing (requires additional code)
    echo: Whether to print the steps as they are executed
    """
    
    if para_mode:
        # Set up empty dataframe for parallel processing of ffmpeg commands
        cmds = pd.DataFrame(columns=['command'])

    # Loop thru each video listed in df
    for c_row in df.index:

        # Total input path (video dir path + filename)
        tot_in_path = in_path + os.sep + df.date[c_row] + os.sep + df.video_filename[c_row] + '.' + suffix_in

        # filename via date_trial system
        if (in_name=='date_trial') or (out_name == 'date_trial'):
            trialnum = format(int(df.trial_num[c_row]),'03')
            datetrial_name = df.date[c_row] + '_' + trialnum

        elif (in_name=='date_sch_trial') or (out_name == 'date_sch_trial'):
            trialnum = format(int(df.trial_num[c_row]),'03')
            schnum = format(int(df.sch_num[c_row]),'03')
            datetrial_name = df.date[c_row] + '_sch' + schnum + '_tr' + trialnum

        # Input path
        if (in_name=='date_trial') or (in_name=='date_sch_trial'):
            tot_in_path = in_path + os.sep + df.date[c_row] + os.sep + datetrial_name + '.' + suffix_in
        else:
            # Total input path (video dir path + filename)
            tot_in_path = in_path + os.sep + df.date[c_row] + os.sep + df.video_filename[c_row] + '.' + suffix_in

        # Total output path (video dir path + filename)
        if (out_name == 'date_trial') or (out_name == 'date_sch_trial'):    
            tot_out_path = out_path + os.sep + datetrial_name + '.' + suffix_out
        else:
            tot_out_path = out_path + os.sep + df.video_filename[c_row] + '.' + suffix_out            

        # Total mask path 
        tot_mask_path = maskpath + os.sep + df.mask_filename[c_row] + '.png'

        if echo:
            # Update status
            print('Converting video ' + str(c_row+1) + ' of ' + str(len(df)))

        # Check for mask path
        if not os.path.isfile(tot_mask_path):
            raise OSError('Mask file does not exist: ' + tot_mask_path)

        # Check for source video
        if not os.path.isfile(tot_in_path):
            raise OSError('Video file does not exist: ' + tot_in_path)

        # Check for output directory
        if not os.path.isdir(out_path):
            raise OSError('Output directory does not exist: ' + out_path)

        # Create movie
        cmd = vt.vid_convert(tot_in_path, tot_out_path, imQuality=imquality, vMode=vmode, 
                             maskpath=tot_mask_path, para_mode=para_mode, echo=echo)

        if para_mode:
            cmds_c = pd.DataFrame([[cmd]],
                                columns=['command'])

            # Add to dataframe
            cmds = pd.concat([cmds, cmds_c], sort=False, ignore_index=True)
        else:
            cmds = cmd

        if echo:
            # Report counter
            print('Finished with ' + str(c_row + 1) + ' of ' + str(len(df)) + ' videos.')

    return cmds
  

def make_calibration_images(path, vid_ext_raw='MOV', vid_ext_mask='mp4', vid_quality=1):
    """ Makes calibration images for each calibration video in df
    
    df - dataframe generated by get_cat_info with the info needed for each video where analyze==1 and make_video==1. The code assumes that videos are in a directory named for the date (e.g. 2022-10-01) for the recording, given in the 'date' column of df.
    path - dictionary with paths to directories for input and output files
    
    """

    # Thickness (in pixels) of border around ROI
    border_pix = 10

    # Extract experiment catalog info
    df = get_cat_info(path['cat'], include_mode='make_video')
    if len(df) == 0:
        raise ValueError('No videos found in catalog file. Analyze make_video must be be set to zero for all')

    # Make unique list of cal_video_filename
    cal_video_filenames = df.cal_video_filename.unique()

    # Loop through each calibration video
    for cal_video_filename in cal_video_filenames:

        # Get index from catalog for first match of cal_video_filename 
        c_row = df[df.cal_video_filename == cal_video_filename].index[0]

        # Define ROI without extra
        roi_x = df.roi_x[c_row] - int(np.ceil(border_pix))
        roi_y = df.roi_y[c_row] - int(np.ceil(border_pix))
        roi_w = df.roi_w[c_row] + int(np.ceil(2*border_pix))
        roi_h = df.roi_h[c_row] + int(np.ceil(2*border_pix))

        r = [int(float(roi_x)), int(float(roi_y)), int(float(roi_w)), int(float(roi_h))]

        # Path for current calibration video
        vid_in_path = path['vidin'] + os.sep + df.date[c_row] + os.sep + cal_video_filename + '.' + vid_ext_raw

        # Define trial filename
        schnum = format(int(df.sch_num[c_row]),'03')
        trialnum = format(int(df.trial_num[c_row]),'03')
        datetrial_name = df.date[c_row] + '_sch' + schnum + '_tr' + trialnum + '_cal.' + vid_ext_mask
        
        # Paths
        tmp_path = path['tmp'] + os.sep + datetrial_name
        cal_vid_path = path['vidcal'] + os.sep + datetrial_name
        mask_path = path['mask'] + os.sep + df.mask_filename[c_row] + '.png'
        im_path =path['imcal'] + os.sep + df.mask_filename[c_row] + '.png'

        # Create movie with mask
        cmd = vt.vid_convert(vid_in_path, tmp_path, imQuality=vid_quality,
                            vMode=False, maskpath=mask_path, para_mode=False, 
                            echo=False)
        
        # Create movie with roi
        cmd = vt.vid_convert(tmp_path, cal_vid_path, imQuality=vid_quality, 
                            vertPix=None, roi=r, vMode=False, para_mode=False, echo=False)

        # Extract frame and save to 'mask' directory
        im = vt.get_frame(cal_vid_path)
        result = cv.imwrite(im_path, im)

        if result is False:
            print('Save to the following path failed: ' + im_path)
        else:
            print('Video frame saved to: ' + im_path)